- Stacking (примерно в 3.6+ версии изменений ядра) Для процессов работающих с файловой системой (ls,rm,cat,tail,head,...) продумать профиль. Возможно потом использовать Profile Stacking, чтобы некий базовый стакать с профилем доступа фс конкретно для пакета-базы. Непонятно как это будет работать, если у нас все так же ограничение всего на 12 переходов на другие профили.
    /bin/** px -> &two,
Will compute the profile transition as per
    /bin/** px,
and then stack the profile two on top of that transition.
    /bin/** ix -> &two,
is equivalent to
    /bin/** px -> @{profile_name}//&two,
Таким образом можно сделать все _root, и убрать дубликаты профилей с незначительными изменениями для запуска под root.
http://wiki.apparmor.net/index.php/AppArmorStacking
http://wiki.apparmor.net/index.php/StackingConfiningUsers
** для версии 3.5 стекинг работает глючно, пробовать потом в 3.6


- Delegation (будет примерно в 4-5 версии изменений ядра), т.к. убунтовские патчи убирают 100% делегейшен на открытые ресурсы в дочерний процесс, надо прописывать это отдельно (указывать какие ресурсы открытые в основном процессе может использовать дочерний). Не совсем понятно, когда это будет доступно хотя бы в утилите, но описание уже есть:
http://wiki.apparmor.net/index.php/AppArmor_Core_Policy_Reference#Delegation
http://wiki.apparmor.net/index.php/AppArmorDelegation#How_Delegation_is_Expressed
http://wiki.apparmor.net/index.php/AppArmorProfileSpec


- Namespaces. Работают, можно делать переходы, например:
	/bin/sleep	Pxr -> :user:sleep,
но зона видимости профилей - только текущий неймспейс. Т.е. если как в примере перешли в неймспейс :user:, то больше недоступны профили из базового неймспейса. Работает только в иерархической структуре, из неймспейса видно только дочерний (профили в нем).
Возможно, если будет возможность работать с переходами в другие неймспейсы, будет иметь смысл использовать их для RBAC. Сейчас они ориентированны только на создания ограничний для контейнеров (собственно, это основная цель у разработчиков).
** In AppArmor 4 it is possible to have the view be a namespace that is different from the current namespace.
http://wiki.apparmor.net/index.php/AppArmorNamespaces
http://wiki.apparmor.net/index.php/AppArmorStacking#Using_Stacking_in_combination_with_Policy_Namespaces
** the current namespace is always the namespace of the profile in the stack having its permissions evaluated
- Позже сделать для неймспейсов ограничения в base абстракции, чтобы сингалы, и прочее не передавались туда-сюда просто так.


- Базовый deny на неподдерживаемые файлы.
У программ, с явным перечнем расширений, блокировать через deny обращение к открытию файлов не имеющие расширений вообще, начинающиеся с точки. Уменьшить вывод предупреждений в лог.
(?) делать по фиксированным путям, чтобы исключить блокировку нужных файлов?


- portage.emerge улучшение ограничений в следующих версиях AppArmor.
Когда будет введен режим исключения в правилах, откорректировать:
/usr/** rwl, # FIX ME! exclude "/usr/local" with {*^}/{**^}, when this features will be available
/var/** rwk, # FIX ME! exclude "/var/log" (allow only subfolder creation and .keep* files) with {*^}/{**^}, when this features will be available


- network улучшение ограничений в следующих версиях AppArmor.
<address_expr> ::= [('source'|'src') <domain_addr> ['on' <iface>]] [('destination'|'dst' <domain_addr>]
<domain_addr> ::= (<ipv4_addr> | <ipv6_addr> | ..)
 network tcp src 192.168.1.1:80 dst 170.1.1.0:80,
 <ipv4_addr> ::= [<ipv4_??>['/'(<ipv_??>|<num>)]][':'<ports>]
 <ipv4_??> ::= <??_expr>'.'<??_expr>'.'<??_expr>'.'<??_expr>
 <??_expr> ::= (<num>|<range>|'*')
 <ports> ::= (<num>|<range>)(','<num>|<range>])*
 <range> ::= <num> '-' <num>
 192.168.1.1
 192.168.1.1-254
 192.168.1.1:80
 192.168.1.1:80,81
 192.168.1.1:80,81,100-200


- "owner" улучшение ограничений в следующих версиях AppArmor.
extended ownership tests (not currently supported)
 eg.
 owner=fred
 owner=1001
 owner=(fred)
 owner=(fred george)
 owner=(fred 1001)
/etc/apparmor.d/abstractions/authentication, например, хорошо бы сделать с owner=0


- mount улучшение ограничений в следующих версиях AppArmor.
Add the ability for apparmor to do mediation of mount operations. Mount
rules require an updated apparmor_parser (2.8 series) for policy compilation.
The basic form of the rules are.
  [audit] [deny] mount [conds]* [device] [ -> [conds] path],
  [audit] [deny] remount [conds]* [path],
  [audit] [deny] umount [conds]* [path],
  [audit] [deny] pivotroot [oldroot=<value>] <path>
  remount is just a short cut for mount options=remount
  where [conds] can be
    fstype=<expr>
    options=<expr>
Example mount commands
  mount,        # allow all mounts, but not umount or pivotroot
  mount fstype=procfs,  # allow mounting procfs anywhere
  mount options=(bind, ro) /foo -> /bar,  # readonly bind mount
  mount /dev/sda -> /mnt,
  mount /dev/sd** -> /mnt/**,
  mount fstype=overlayfs options=(rw,upperdir=/tmp/upper/,lowerdir=/) -> /mnt/
  umount,
  umount /m*,


