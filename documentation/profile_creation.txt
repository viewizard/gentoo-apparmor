FIX ME! - маркеровка проблемных участков или участков, на которые надо обратить внимание.
BUG! - маркеровка пакетов, где были выявлена некоректная работа НЕ зависящая от профиля AppArmor.
RBAC! - маркеровка блоков связанных с ролевым ограничением. Т.к. часть профилей мы должны делать общими для всех ролей (из-за ограниченного кол-ва переходов профилей), маркеруем такие участки, возможно, в будущем мы сможем использовать другие механизмы RBAC.
DELEGATION! <Имя родительского профиля> - маркировка блоков для последующего использования в функционале Delegation, которые не должны присутствовать в профиле, а должны делегироваться родительским профилем. Используем один маркер для двух случаев: 1) маркировка наследуемых ресурсов; 2) маркировка блоков делегируемых во время переключения профиля при запуске процесса.
FS ACCESS! [<Имя временного дочернего профиля>] - пока не поддерживается возможность делегирования в профиль во время переключения (на состояние модуля ядра 3.6, юзерспейс 2.11.0), маркеруем такие ix вызовы, для последующего использования с Px+{} (с делегированием доступов к файловой системе во время переключения профиля).
LINK! <Переменная> - т.к. цель линка не может содержать переменных (@{}) (на состояние модуля ядра 3.6, юзерспейс 2.11.0), маркируем такие блоки с указанием переменной, чтобы при изменении переменной корректировать профили.
BUILD SYSTEM ONLY! - профиль должен использоваться только на системах сборки.
(?) - маркер предположения, требуется собрать больше информации. Может быть как самостоятельным, так и дополняющим маркером к любому другому маркеру из описанных выше.


написать инструкцию составления правил apparmor

настройка редактора:
	ширина TAB = 8 символов

- название файла должно соответствовать названию пакета в portage
	Исключение (пишем перед профилем "<номер>_", чтобы гарантировать отсутствие пакета с таким именем)
	0_default - default профиль (/**)
	1_shell - общие профили шела
	2_local - профили для пользовательских программ в /etc/cron.*/, /usr/local/bin/*, /usr/local/sbin/*
	3_kernel - профили для скриптов в /usr/src/*
	Для файлов с профилями в неймспейсе, <название пакета>:<неймспейс>
- название профилей:
	в случае простого профиля - должно быть идентично названия пакета в portage
	в случае нескольких профилей - должно содержать название пакета перед названием исполняемого файла, разделенного точкой, например "acpid.acpi_listen"
	исключения:
	если профиль вызывается непосредственно из другого профиля, использование символа точки и дефиса недопустимо - заменять в вызываемом профиле все недопустимые символы нижним подчеркиванием. Например:
		/usr/bin/thunar Px -> thunar_root,
	скрипты в /etc/init.d/* - <название пакета>.<имя файла>.init.d
	скрипты в /etc/cron.*/* - <название пакета>.<имя файла>.cron.{daily,hourly,monthly,weekly}
	default профиль должен быть в /etc/apparmor.d/0_default, нельзя менять название файла с 0_default на другое (используется в скриптах инициализации initramfs).


Важно! Правила профиля не учитывают расположения строк.
Т.е. запись 
@{HOME}=@{HOMEDIRS}/*/ /root/
@{HOMEDIRS}=/home/
или 
@{HOMEDIRS}=/home/
@{HOME}=@{HOMEDIRS}/*/ /root/
равнозначны.
Аналогично и для запрещающих правил:
deny /test r,
/** r,
или
/** r,
deny /test r,
будет блокировать доступ к файлу /test на чтение в обоих случаях. Необходимо учитывать, что AppArmor работает по принципу приоритетов:
	1) явно заданный deny для конечного объекта (в случае complain режима, может не работать!)
	2) разрешающее правило
	3) если профиль не содержит информации по объекту, применение разрещающего правила в случае complain режима или блокирующего в случае enforce.


Важно! Кол-во именованных (Px ->, Сx ->) переходов профиля не должно превышать 12 для одного профиля.
В случае превышения, будет выдана ошибка:
Profile имя_профиля has too many specified profile transitions.
Крайне желательно вызов дочерних профилей (Cx) делать по исполняемому файлу (без Cx -> "дочерний_профиль"), а не по названию. Или использовать переход на один общий профиль с расширенными допусками.



1) Порядок расположение правил доступа: PpCcUuIixmrawkl
Устанавливаем нужные правила доступа для объекта согласно расположению, пропуская остальные.
Примеры:
	чтение и запись: rw
	чтение и исполнение с существующим профилем, если профиля нет использовать текущий: Pixr,
	чтение, запись, создание линка, разрешение лочить: rwkl
	чтение, запись и разрешение загрузки в память: mrw
Более подробно:
	http://wiki.apparmor.net/index.php/AppArmor_Core_Policy_Reference#File_access_rules
* использовать "l" только в случае "/path l," = "link subset /path -> /**,". В остальных случаях указывать конечную цель линка.


2) Составление профиля. Порядок следование блоков:
# CAPABILITIES ---------------------------------------
# AUDIT CAPABILITIES ---------------------------------
# PTRACE ---------------------------------------------
ptrace (trace),
# AUDIT PTRACE ---------------------------------------
# SIGNAL ---------------------------------------------
signal (send) set=(usr1) peer="xinit",
# AUDIT SIGNAL ---------------------------------------
# UNIX -----------------------------------------------
  unix (bind, listen)
  			type=stream
  			addr="@/tmp/dbus-*",
  unix (send, receive, accept)
  			type=stream
  			addr="@/tmp/dbus-*"
  			peer=(label="nvidia-drivers.nvidia-settings"),
# AUDIT UNIX -----------------------------------------
# DBUS -----------------------------------------------
# AUDIT DBUS -----------------------------------------
# MOUNT ----------------------------------------------
mount umount
# AUDIT MOUNT ----------------------------------------
# NETWORK --------------------------------------------
network netlink raw,
network inet dgram,
network inet6 dgram,
# AUDIT NETWORK --------------------------------------
# PSEUDO ---------------------------------------------
все что входит в /dev, /sys, /proc
# AUDIT PSEUDO ---------------------------------------
# EXECUTABLES ----------------------------------------
все что запускается (не зависимо от места), файл профиля, указывать остальные разрешения (кроме запускаемых)
Важно! никогда не "сворачивать" в {}, исключение - симлинки/хардлинки или старые/новые название одного и того же исполняемого файла.
Порядок: исполняемый файл профиля, /bin, /sbin, /usr/bin, /usr/sbin, /opt, остальные
Крайне не желательно использовать запуск процесса в текущем профиле (ix), необходимо стараться ограничить новый процесс -использовать запуск через дочерние профили по Cx, или Px. Исключение для ix: профили в которых по каким-то причинам очень трудно/невозможно избавится от ix, запускаемые только супер пользователем и не являющиеся службой (не находятся в памяти постоянно), в идеале, профили доступные только на тестовых/сборочных системах (т.е. профили программ, которые не будут установлены в конечной, пользовательской системе).
# AUDIT EXECUTABLES ----------------------------------
"audit" или "audit deny" для исполняемых файлов, когда нельзя запускать, но надо зафиксировать
# READS/WRITES ---------------------------------------
все, что записывае-читаем в порядке: /etc, /usr, /opt, /run, /var
# AUDIT READS/WRITES ---------------------------------
# USERS ----------------------------------------------
все, что записывае-читаем в /home
# AUDIT USERS ----------------------------------------
"audit" или "audit deny" для файлов
# TEMP -----------------------------------------------
все, что записывае-читаем в  /tmp, /var/tmp
обязательно делать для каждого отдельно, чтобы в последствии можно было сделать изоляцию X сервера
Важно, чтобы запись была привязана к владельцу процесса (owner), содержала уникальное для программы блок, или задавать точное кол-во символов, например:
	/tmp/ r,
	owner /tmp/alacarte-* rw,
	owner /tmp/??????	rw,
Не допускать записи вида: /tmp/* или /tmp/**
# AUDIT TEMP -----------------------------------------
# NOISY ----------------------------------------------
Фактически - правила блокировка вывода в лог сообщений.
# DENY INHERIT ---------------------------------------
Если наследуем, но не нужно давать доступ на эти ресурсы. Так же, может понадобиться прописать flags=(attach_disconnected) и "deny /apparmor/.null rw," в случае, если часть ресурсов в дисконнекте.
Особенности запреда наследования (пока не введут нормальную реализацию наследования):
Родительский профиль -> 1й процесс, ставим просто deny -> 2й процесс запущенный из первого, ставим flags=(attach_disconnected) и "deny /apparmor/.null ?,"
Т.е. второй процесс и далее не видит ресурсов, они дисконектнуты для них, чтобы не вываливало в лог это сообщения - подключаем и запрещаем (дисконектнутый ресурс запретить нельзя по deny). Особый случай, если профиль использует ix запуск или запускает сам себя.


3) Абстракции (объединение части используемых групп правил).
Расположение: /etc/apparmor.d/abstractions
Основное правило - писать название абстракций разделяя слова символами "-" или ".". Нижнее подчеркивание в конце - тип ветки (исключение: нижнее подчеркивание используется в названии модуля/программы/пакета). Для root ветки соотв. _root или _sudo (особый случай, когда UID 0, но могут быть особые нюансы работы).
Если возможно, избегать вложений abstractions в другие abstractions.
Если необходимо вынести в абстракции запуск других процессов - использовать профили с запуском по Px/Cx, и только в крайнем случае использовать запуск в текущем профиле через ix (в основном, это необходимо для интерпритаторов таких как perl, python и openrc-run.sh из openrc).


abstractions/dbus, abstractions/dbus-session, abstractions/dbus-accessibility - использовать только в процессе отладки, в конечных профилях должны использоваться ограниченные (-strict) версии.
abstractions/dbus-pattern/session-bind - иногда используется как часть механизма проверки уже запущенной копии программы, в случае применения, необходимо проверить запуск 2 и более копий. Если используется бинд - значит в профиле должна быть секция DBUS (иначе, надо понимать, зачем программа биндит dbus).
abstractions/dbus-pattern/at-spi - Assistive Technology Service Provider Interface, фича gnome 2+. Как правило, используется только в gnome-программах, а не во всех gtk-программах.
abstractions/dconf - как правило, gtk-программы работают с dconf на прямую (без gconf).
abstractions/dbus-pattern/gconf - может использоваться qt-программами для взаимодействия по dbus с "реестром настроек" в gnome-окружении.
abstractions/qt - включает в себя abstractions/gtk, т.к. нужна поддержка GTK+ стиля.


4) Локальные правила.
Фрагменты профилей (в т.ч. дочерние под профили).
Расположение:  /etc/apparmor.d/local
Набор профилей (полноценные профили, кроме глобального инклуда), для всех локальных программ и скриптов.
Обход и загрузка профилей выполняется через профиль /etc/apparmor.d/2_local.
Расположение:
/etc/apparmor.d/local/bin.d
/etc/apparmor.d/local/cron.d
/etc/apparmor.d/local/sbin.d


5) Глобальные настройки (переменные, окружение и т.п.).
Расположение:  /etc/apparmor.d/tunables
@{CHOST}
@{BLOCK_VIRT}
@{BLOCK_MEDIA}
@{BLOCK_REAL}
@{BLOCK_ALL}
@{PROC}
@{HOME}
@{HOME_USERS}
@{HOMEDIRS}
@{HOME_CACHE}
@{shell}
@{kernel_ver}
@{kernel}
@{pid}
@{PYTHON}
@{PYTHON_PACKAGES}
@{PYTHON_EXEC}
@{PYTHON2}
@{PYTHON2_PACKAGES}
@{PYTHON2_EXEC}
@{PYTHON3}
@{PYTHON3_PACKAGES}
@{PYTHON3_EXEC}
@{PYTHON_EXEC_WRAPPER}
@{XDG_DESKTOP_DIR}="Desktop" "Рабочий стол"
@{XDG_DOWNLOAD_DIR}="Downloads" "Загрузки"
@{XDG_TEMPLATES_DIR}="Templates" "Шаблоны"
@{XDG_PUBLICSHARE_DIR}="Public" "Общедоступные"
@{XDG_DOCUMENTS_DIR}="Documents" "Документы"
@{XDG_MUSIC_DIR}="Music" "Музыка"
@{XDG_PICTURES_DIR}="Pictures" "Изображения"
@{XDG_VIDEOS_DIR}="Videos" "Видео"




http://wiki.apparmor.net/index.php/AppArmorRBAC
Для RBAC используем принцип различных веток правил (Profile tree).
Для root-профилей существует абстракция "fs-access-by-pattern-systemusers" предоставляющая доступ к файлам (владельцы - системные и специальные пользователи) с ограничениями DAC.

Profile Namespaces:
http://wiki.apparmor.net/index.php/AppArmorNamespaces
Предположительно, изменения в ядре только убунтовском, в апстриме его нет или поддержка частичная.

Profile Stacking
http://wiki.apparmor.net/index.php/AppArmorStacking
Предположительно, изменения в ядре только убунтовском, в апстриме его нет или поддержка частичная.





Важно!
При внесении изменений в настройки или абстракции - перегенерировать бинарный кэш профилей самостоятельно, т.к. парсер не определяет время изменений всех вложенных файлов!
Компиляция бинарных кэшей должна выполнятся на ядре с таким же функционалом, какой имеется у ядра в конечном компьютере, где производится запуск и загрузка этих бинарных кэшей.
Удаление бинарных кешей (команда одной строкой):
find /etc/apparmor.d/cache -type f ! -iname ".*" -exec rm {} \;
Гнерирование бинарных кешей (команда одной строкой):
LANG=C; for p in /etc/apparmor.d/*; do if [ -f $p ]; then apparmor_parser -rWQ $p; if [ "$?" != "0" ]; then break; fi; fi; done

Важно!
Шелл (/bin/bash) всегда должен быть в своем профиле, необходимо избегать использование ix из общего профиля, особенно если это GUI с большим кол-вом используемых абстракций.
В случае, если шелл вызывается из вложенного профиля, необходимо делать отдельный профиль и использовать "Px ->". Если будет добавлена возможность использования вложенных профилей во вложенных профилях черех "Cx ->", переделать.

Важно!
capability dac_read_search и dac_override,
перекрывают настройки DAC, должны применяться только в случае RBAC с root (sudo) или в случаях, когда это действительно нужно (это не должно быть нужно, если программа не запускается под root-ом).

Важно!
Если программа подразумевает аутентификацию через PAM, обязательно использовать hat по умолчанию (^DEFAULT, при необходимости - делать пустым {}), иначе будет работать с основным профилем программы (не переходить в hat).

Важно!
Не блокировать скрытые файлы домашней директории, например "deny @{HOME}/.* r", т.к. это может привести к блокировке нужных файлов, например, @{HOME}/.Xauthority.

Важно!
Нельзя совмещать в одном файле профили входящие в разные неймспейсы. На состояние версии утилиты 2.11 и ядра 3.5, после компиляции в бинарный кэш и загрузке - все профили будут в одном неймспейсе.

Важно!
Линки, если это не общие линки на всю систему делать через link, а не "l". С более жесткими ограничениями. По умолчанию,
"/path l," = "link subset /path -> /**,"
http://wiki.apparmor.net/index.php/AppArmor_Core_Policy_Reference#Link_Rules

Важно!
На линках ("link" или "l") может не работать audit. Для проверки надо убирать правило с линком и переводить весь профиль в flags=(complain).
(патч ядра 3.6, юзерспейс 2.11.0) Цель линка не должна содержать переменные (например, @{HOME}). Может быть прописан как рег эксп, но без переменных.

Важно!
Участки файловой системы с массовым общим доступом программ, такие как: /tmp/, /var/tmp/, /dev/shm/ - должны быть со строгими правилами доступа: owner (если возможно), указание фрагментов (например, название программы), указание кол-ва символов (если генерируется только случайная часть в названии).

Важно!
Не используем утилиты (aa-complain, aa-enforce, aa-disable, aa-logprof) - перед выполнением проверяет все профили (причем не учитывая добавленный функционал, например, link), требует расположение профилей и их частей строго в соответствии с тараканами разработчиков apparmor (т.е. ругается на любые файлы и директории с произвольными файлами, поддиректории с профилями содержащими дочернии профили и т.п.). Непонятно почему разработка утилит идет не совместно с парсером и ядром (хотя все делается одной группой людей).
aa-logprof - не корректно отрабатывает вынесение общих частей в абстракции, работу с под профилями. Не функциональна в случае полносистемного RBAC с покрытием всех процессов.
aa-complain, aa-enforce - непонятно, зачем проверяет все профили и структуру, если работае только с одним профилем.
aa-disable - вообще непонятно, зачем проверяет профили, если цель работы - создание симлинка в директории "disable".

Важно!
При обновлении систем инициализации (sys-apps/openrc, sys-apps/systemd) или ядра, обязательно переводить систему в режим force-complain:
root # cd /etc/apparmor.d/
root # find * -maxdepth 0 -type f -exec ln -sr ./{} ./force-complain/{} \;
В противном случае, может возникнуть ситуация, когда изменения не позволят загрузиться.

Важно!
При использовании на профиле "shadow.login" flags=(complain) или force-complain, AppArmor будет требовать hat пользователя (если в pam указан первый пользователь). Т.е. надо учитывать, что в случае обучения, AppArmor будет считать, что профиль "shadow.login" должен содержать правильный hat.

Важно!
Программы, работающие с интернетом с изолированным доступом к файловой системе должны использовать абстракцию abstractions/fs-access-by-pattern-internet.

Важно!
Если прорамма работает с интернетом и вносит изменения или создаёт файлы за пределами абстракции abstractions/fs-access-by-pattern-internet, необходимо добавить перечень этих файлов (директорий) в абстракцию abstractions/fs-deny-by-pattern-internet.

Важно!
Для программ, использующих доступ к пользовательским файлам без ограничений (например, используется abstractions/fs-access-by-users-preset-r* с @{USERS_FILE}="**") обязательно использовать абстракции abstractions/fs-deny-private или abstractions/fs-deny-private-strict. Исключения - работа с файлами из этих абстракций.

Важно!
После обновления системы, установки и/или удаления пакетов через portage - выполнять проверку скриптом /usr/local/sbin/aa_portage.sh на необходимость включения/отключения (через симлинк в /etc/apparmor.d/disable/) профилей AppArmor.
Скрипт автиматически создает или удаляет симлинки из директории /etc/apparmor.d/disable/. В случае, если скриптом были выполнены действия, необходимо удалить и создать новый набор бинарных кэшей профилей.
########################################################################################
#!/bin/bash

# Скрипт проверяет соответствие рабочих и выключенных профилей AppArmor.

AA_PROFILES="/etc/apparmor.d"

for p in ${AA_PROFILES}/*; do

	if [ ! -f $p ]; then
		continue
	fi

	case "${p}" in
		# Базовые профили, не имеющие пакетов.
		${AA_PROFILES}/0_default|${AA_PROFILES}/1_shell|${AA_PROFILES}/2_local|${AA_PROFILES}/3_kernel)
			continue
		;;
		# Профили пользователя (программы без пакетов, установленные в домашнюю директорию).
		${AA_PROFILES}/evelauncher)
			continue
		;;
		# Проверяем все профили.
		*)
			BMANE=$(basename ${p})
			RES="$(equery list --format='$category/$name' $BMANE)"
			#if [ "$(echo "$RES" | wc -l)" != "1" ]; then
			#	echo "Несколько установленных пакетов соответствуют одному имени: $RES"
			#fi
			if [ "$RES" == "" ]; then
				# "Пакет не установлен."
				if [ ! -L "${AA_PROFILES}/disable/$BMANE" ]; then
					echo "$BMANE - пакет не установлен, не обнаружен симлинк в ./disable/"
					ln -sr "${AA_PROFILES}/$BMANE" "${AA_PROFILES}/disable/$BMANE" || \
						echo "... ошибка создания симлинка."
				fi
			else
				# "Пакет установлен."
				if [ -L "${AA_PROFILES}/disable/$BMANE" ]; then
					echo "$BMANE - пакет установлен, обнаружен симлинк в ./disable/"
					rm "${AA_PROFILES}/disable/$BMANE" || \
						echo "... ошибка удаления симлинка."
				fi
			fi
		;;
	esac

done
########################################################################################














Отладка.

/var/log/audit.log

flags=(complain)
apparmor_parser -r /etc/apparmor.d/bash
apparmor_parser -R /etc/apparmor.d/bash

Перевести все профили в принудительный отладочный режим:
root # cd /etc/apparmor.d/
root # find * -maxdepth 0 -type f -exec ln -sr ./{} ./force-complain/{} \;


Получение списка процессов, например, unconfined (запущенных без профиля):
ps aux -Z | grep "unconfined"



После добавления нового профиля - проверить по имени процесса все профили.
Если данный процесс используется в других профилях с "ix" переделать на "Px" (проверить в профиле пересекающееся использование ресурсов через audit).




Отладка профилей процессов выполняющихся после остановки службы syslog-ng.

/etc/syslog-ng/syslog-ng-test-audit.conf
########################################################################################
@version: 3.7
# $Id$

@include "scl.conf"

options { 
	threaded(yes);
	chain_hostnames(no); 
	stats_freq(43200); 
	mark_freq(3600); 
};

source kernel {
	file("/proc/kmsg");
};

destination console_all { file("/dev/tty12"); };
filter f_audit { message("^(\\[.*\..*\] |)audit.*") and not message(".*avc: .*"); };
log { source(kernel); filter(f_audit); destination(console_all); };
########################################################################################

# Тестовая конфигурация для проверки профилей Apparmor.
# 1) Останавливаем службу
#	/etc/init.d/syslog-ng stop
# 2) Запускаем в терминале:
#	/usr/sbin/syslog-ng --persist-file "/var/lib/syslog-ng/syslog-ng.persist" --cfgfile "/etc/syslog-ng/syslog-ng-test-audit.conf" --pidfile "/run/syslog-ng.pid" &
# 3) Выключаем/перезагружаем компьютер, смотрим в 12-ю консоль
