FIX ME! - маркеровка проблемных участков или участков, на которые надо обратить внимание.
BUG! - маркеровка пакетов, где были выявлена некоректная работа НЕ зависящая от профиля AppArmor.
RBAC! - маркеровка блоков связанных с ролевым ограничением. Т.к. часть профилей мы должны делать общими для всех ролей (из-за ограниченного кол-ва переходов профилей), маркеруем такие участки, возможно, в будущем мы сможем использовать другие механизмы RBAC.
DELEGATION! <Имя родительского профиля> - маркировка блоков для последующего использования в функционале Delegation, которые не должны присутствовать в профиле, а должны делегироваться родительским профилем. Суть в том, что в случае с делегированием мы не позволяем дочернему профилю работать с ресурсами напрямую, он может работать только с ресурсами открытыми/задействованными в родительском профиле.
PROFILE LIST! <Имя родительского профиля> - маркировка блоков для последующего использования в функционале объединения профилей (дополнение правил профилей).
STACKING! <Имя родительского профиля> - маркировка блоков для последующего использования в функционале Stacking (пересечение правил профилей).
(?) - маркер предположения, требуется собрать больше информации. Может быть как самостоятельным, так и дополняющим маркером к любому другому маркеру из описанных выше.




написать инструкцию составления правил apparmor

настройка редактора:
	ширина TAB = 8 символов

- название файла должно соответствовать названию пакета в portage
	Исключение (пишем перед профилем "<номер>_", чтобы гарантировать отсутствие пакета с таким именем)
	0_default - default профиль (/**)
	1_shell - общие профили шела
	2_local - профили для пользовательских программ в /etc/cron.*/, /usr/local/bin/*, /usr/local/sbin/*
	3_kernel - профили для скриптов в /usr/src/*
	Для файлов с профилями в неймспейсе, <название пакета>:<неймспейс>
- название профилей:
	в случае простого профиля - должно быть идентично названия пакета в portage
	в случае нескольких профилей - должно содержать название пакета перед названием исполняемого файла, разделенного точкой, например "acpid.acpi_listen"
	исключения:
	если профиль вызывается непосредственно из другого профиля, использование символа точки и дефиса недопустимо - заменять в вызываемом профиле все недопустимые символы нижним подчеркиванием. Например:
		/usr/bin/thunar Px -> thunar_root,
	скрипты в /etc/init.d/* - <название пакета>.<имя файла>.init.d
	скрипты в /etc/cron.*/* - <название пакета>.<имя файла>.cron.{daily,hourly,monthly,weekly}


Важно! Правила профиля не учитывают расположения строк.
Т.е. запись 
@{HOME}=@{HOMEDIRS}/*/ /root/
@{HOMEDIRS}=/home/
или 
@{HOMEDIRS}=/home/
@{HOME}=@{HOMEDIRS}/*/ /root/
равнозначны.
Аналогично и для запрещающих правил:
deny /test r,
/** r,
или
/** r,
deny /test r,
будет блокировать доступ к файлу /test на чтение в обоих случаях. Необходимо учитывать, что AppArmor работает по принципу приоритетов:
	1) явно заданное deny для конечного объекта
	2) разрешающее правило
	3) применение разрещающего правила в случае complain режима, или блокирующего в случае enforce.


Важно! Кол-во уникальных переходов профиля не должно превышать 12 для одного профиля (Px ->, Сx ->).
В случае превышения, будет выдана ошибка:
Profile имя_профиля has too many specified profile transitions.
Крайне желательно вызов дочерних профилей (Cx) делать по исполняемому файлу (без Cx -> "дочерний_профиль"), а не по названию. Или использовать переход на один общий профиль с расширенными допусками.



1) Порядок расположение правил доступа: PpCcUuIixmrawkl
Устанавливаем нужные правила доступа для объекта согласно расположению, пропуская остальные.
Примеры:
	чтение и запись: rw
	чтение и исполнение с существующим профилем, если профиля нет использовать текущий: Pixr,
	чтение, запись, создание линка, разрешение лочить: rwkl
	чтение, запись и разрешение загрузки в память: mrw
Более подробно:
	http://wiki.apparmor.net/index.php/AppArmor_Core_Policy_Reference#File_access_rules
* использовать "l" только в случае "/path l," = "link subset /path -> /**,". В остальных случаях указывать конечную цель линка.


2) составление профиля
# CAPABILITIES ---------------------------------------
# AUDIT CAPABILITIES ---------------------------------
# PTRACE ---------------------------------------------
ptrace (trace),
# AUDIT PTRACE ---------------------------------------
# SIGNAL ---------------------------------------------
signal (send) set=(usr1) peer="xinit",
# AUDIT SIGNAL ---------------------------------------
# UNIX -----------------------------------------------
  unix (bind, listen)
  			type=stream
  			addr="@/tmp/dbus-*",
  unix (send, receive, accept)
  			type=stream
  			addr="@/tmp/dbus-*"
  			peer=(label="nvidia-drivers.nvidia-settings"),
# AUDIT UNIX -----------------------------------------
# DBUS -----------------------------------------------
# AUDIT DBUS -----------------------------------------
# MOUNT ----------------------------------------------
mount umount
# AUDIT MOUNT ----------------------------------------
# NETWORK --------------------------------------------
network netlink raw,
# AUDIT NETWORK --------------------------------------
# PSEUDO ---------------------------------------------
все что входит в /dev, /sys, /proc
# AUDIT PSEUDO ---------------------------------------
# EXECUTABLES ----------------------------------------
все что запускается (не зависимо от места), файл профиля, указывать остальные разрешения (кроме запускаемых)
Важно! никогда не "сворачивать" в {}, исключение - симлинки/хардлинки или старые/новые название одного и того же исполняемого файла.
Порядок: исполняемый файл профиля, /bin, /sbin, /usr/bin, /usr/sbin, /opt, остальные
# AUDIT EXECUTABLES ----------------------------------
"audit" или "audit deny" для исполняемых файлов, когда нельзя запускать, но надо зафиксировать
# READS/WRITES ---------------------------------------
все, что записывае-читаем в порядке: /etc, /usr, /opt, /run, /var
# AUDIT READS/WRITES ---------------------------------
# USERS ----------------------------------------------
все, что записывае-читаем в /home
# AUDIT USERS ----------------------------------------
"audit" или "audit deny" для файлов
# TEMP -----------------------------------------------
все, что записывае-читаем в  /tmp, /var/tmp
обязательно делать для каждого отдельно, чтобы в последствии можно было сделать изоляцию X сервера
Важно, чтобы запись была привязана к владельцу процесса (owner), содержала уникальное для программы блок, или задавать точное кол-во символов, например:
	/tmp/ r,
	owner /tmp/alacarte-* rw,
	owner /tmp/??????	rw,
Не допускать записи вида: /tmp/* или /tmp/**
# AUDIT TEMP -----------------------------------------
# NOISY ----------------------------------------------
Фактически - правила блокировка вывода в лог сообщений.
# DENY INHERIT ---------------------------------------
Если наследуем, но не нужно давать доступ на эти ресурсы. Так же, понадобятся flags=(attach_disconnected) и deny /apparmor/.null rw


/etc/apparmor.d/abstractions
/etc/apparmor.d/local
/etc/apparmor.d/tunables
@{CHOST}
@{BLOCK_VIRT}
@{BLOCK_MEDIA}
@{BLOCK_REAL}
@{BLOCK_ALL}
@{PROC}
@{HOME}
@{HOME_USERS}
@{HOMEDIRS}
@{HOME_CACHE}
@{shell}
@{kernel_ver}
@{kernel}
@{pid}
@{PYTHON}
@{PYTHON_PACKAGES}
@{PYTHON_EXEC}
@{PYTHON2}
@{PYTHON2_PACKAGES}
@{PYTHON2_EXEC}
@{PYTHON3}
@{PYTHON3_PACKAGES}
@{PYTHON3_EXEC}
@{PYTHON_EXEC_WRAPPER}
@{XDG_DESKTOP_DIR}="Desktop" "Рабочий стол"
@{XDG_DOWNLOAD_DIR}="Downloads" "Загрузки"
@{XDG_TEMPLATES_DIR}="Templates" "Шаблоны"
@{XDG_PUBLICSHARE_DIR}="Public" "Общедоступные"
@{XDG_DOCUMENTS_DIR}="Documents" "Документы"
@{XDG_MUSIC_DIR}="Music" "Музыка"
@{XDG_PICTURES_DIR}="Pictures" "Изображения"
@{XDG_VIDEOS_DIR}="Videos" "Видео"




http://wiki.apparmor.net/index.php/AppArmorRBAC
Для RBAC используем принцип различных веток правил (Profile tree).
Для root-профилей существует абстракция "user-systemwide-files" предоставляющая доступ к файлам с ограничениями DAC.

Profile Namespaces:
http://wiki.apparmor.net/index.php/AppArmorNamespaces
Предположительно, изменения в ядре только убунтовском, в апстриме его нет или поддержка частичная.

Profile Stacking
http://wiki.apparmor.net/index.php/AppArmorStacking
Предположительно, изменения в ядре только убунтовском, в апстриме его нет или поддержка частичная.


Если возможно, избегать вложений abstractions в другие abstractions.



Важно!
При внесении изменений в настройки или абстракции - перегенерировать бинарный кэш профилей самостоятельно, т.к. парсер не определяет время изменений всех вложенных файлов!

Важно!
Шелл (/bin/bash) всегда должен быть в своем профиле, необходимо избегать использование ix из общего профиля, особенно если это GUI с большим кол-вом используемых абстракций.
В случае, если шелл вызывается из вложенного профиля, необходимо делать отдельный профиль и использовать "Px->". Если будет добавлена возможность использования вложенных профилей во вложенных профилях черех "Cx->", переделать.

Важно!
capability dac_read_search и dac_override,
перекрывают настройки DAC, должны применяться только в случае RBAC с root или в случаях, когда это действительно нужно.

Важно!
Если программа подразумевает аутентификацию через PAM, обязательно использовать hat по умолчанию (^DEFAULT), иначе будет работать с основным профилем программы.

Важно!
Не блокировать скрытые файлы домашней директории, например "deny @{HOME}/.* r", т.к. это может привести к блокеровки нужных файлов, например, @{HOME}/.Xauthority.

Важно!
Компиляция бинарных кэшей должна выполнятся на ядре с таким же функционалом, какой имеется у ядра в конечном компьютере, где производится запуск и загрузка этих бинарных кэшей.

Важно!
Нельзя совмещать в одном файле профили входящие в разные неймспейсы. На состояние версии утилиты 2.11 и ядра 3.5, после компиляции в бинарный кэш и загрузке - все профили будут в одном неймспейсе.

Важно!
Линки, если это не общие линки на всю систему делать через link, а не "l". С более жесткими ограничениями. По умолчанию,
"/path l," = "link subset /path -> /**,"
http://wiki.apparmor.net/index.php/AppArmor_Core_Policy_Reference#Link_Rules

Важно!
На линках ("link" или "l") может не работать audit. Для проверки надо убирать правило с линком и переводить весь профиль в flags=(complain). 

Важно!
Участки файловой системы с массовым общим доступом программ, такие как: /tmp/, /var/tmp/, /dev/shm/ - должны быть со строгими правилами доступа: owner (если возможно), указание фрагментов (например, название программы), указание кол-ва символов (если генерируется только случайная часть в названии).



Отладка.

/var/log/audit.log

flags=(complain)
apparmor_parser -r /etc/apparmor.d/bash
apparmor_parser -R /etc/apparmor.d/bash

Перевести все профили в принудительный отладочный режим:
root # cd /etc/apparmor.d/
root # find * -maxdepth 0 -type f -exec ln -sr ./{} ./force-complain/{} \;



После добавления нового профиля - проверить по имени процесса все профили.
Если данный процесс используется в других профилях с "ix" переделать процессы на "Px" или "Pix"




Отладка профилей процессов выполняющихся после остановки службы syslog-ng.

/etc/syslog-ng/syslog-ng-test-audit.conf
########################################################################################
@version: 3.7
# $Id$

@include "scl.conf"

options { 
	threaded(yes);
	chain_hostnames(no); 
	stats_freq(43200); 
	mark_freq(3600); 
};

source kernel {
	file("/proc/kmsg");
};

destination console_all { file("/dev/tty12"); };
filter f_audit { message("^(\\[.*\..*\] |)audit.*") and not message(".*avc: .*"); };
log { source(kernel); filter(f_audit); destination(console_all); };
########################################################################################

# Тестовая конфигурация для проверки профилей Apparmor.
# 1) Останавливаем службу
#	/etc/init.d/syslog-ng stop
# 2) Запускаем в терминале:
#	/usr/sbin/syslog-ng --persist-file "/var/lib/syslog-ng/syslog-ng.persist" --cfgfile "/etc/syslog-ng/syslog-ng-test-audit.conf" --pidfile "/run/syslog-ng.pid" &
# 3) Выключаем/перезагружаем компьютер, смотрим в 12-ю консоль
